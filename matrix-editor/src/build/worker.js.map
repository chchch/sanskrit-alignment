{
  "version": 3,
  "sources": ["../build/worker.js"],
  "sourcesContent": ["//import { Fitch as _Fitch } from './lib.fitch.mjs';\nvar mss,levels,num,id;\n\nconst Fitch = function(mss,levels) {\n\n    const set = {\n        Intersection: function(...sets) {\n            const setA = sets[0];\n            return new Set(\n                [...setA].filter(el => {\n                    for(let n=1;n<sets.length;n++) {\n                        if(!sets[n].has(el))\n                            return false;\n                    }\n                    return true;\n                })\n            );\n        },\n\n        Union: function(...sets) {\n            return new Set(\n                sets.reduce((acc, cur) => {\n                    acc = [...acc,...cur];\n                    return acc;\n                },[])\n            );\n        },\n    };\n\n    const fitch1 = function(target) {\n        const firstpass = new Map();\n        for(const taxon of levels[0]) {\n            const val = mss.get(taxon);\n            const reading = val !== undefined ? [val] : [];\n            firstpass.set(taxon,new Set(reading));\n        }\n        for(let m=1;m<levels.length;m++) { // start at 1 (after taxa)\n            for(const [node,children] of levels[m]) {\n                const readings = children.map(node => firstpass.get(node));\n                const intersection = set.Intersection(...readings);\n            \n                // shortcut, if we only care about one node\n                if(target && node === target && intersection.size === 1)\n                    return [...intersection][0];\n\n                const result = intersection.size > 0 ?\n                    intersection :\n                    set.Union(...readings);\n                firstpass.set(node,result);\n\n            }\n        }\n        return firstpass;\n\n    };\n\n    const fitch2 = function(firstpass,target) {\n        const taxa = levels[0];\n        const secondpass = new Map();\n        \n        for(const level of levels[levels.length-1])\n            secondpass.set(level[0],firstpass.get(level[0]));\n\n        for(let n=levels.length-1;n>1;n--) {\n            for(const [node,children] of levels[n]) {\n                const ancestral = secondpass.get(node);\n                for(const child of children) {\n                    if(taxa.indexOf(child) !== -1)\n                        continue;\n                    const childreading = firstpass.get(child);\n                    const result = (() => {\n                        if(childreading.size === 1)\n                            return childreading;\n\n                        const intersection = set.Intersection(ancestral,childreading);\n                        return intersection.size > 0 ?\n                            intersection :\n                            childreading;\n                    })();\n                    \n                    // if reading of target node found, skip rest of reconstruction\n                    if(target && child === target)\n                        return result;\n\n                    secondpass.set(child,result);\n                }\n            }\n        }\n        return target ? secondpass.get(target) : secondpass;\n    };\n\n    const fitch = function(target = null) {\n        const firstpass = fitch1(target);\n        if(typeof firstpass === 'string') {\n            return firstpass;\n        }\n    \n        // do the second pass if the first pass is inconclusive\n        const secondpass = fitch2(firstpass,target);\n        return target ? formatOutput(secondpass) :\n            new Map(Array.from(secondpass,([key,val]) => [key,formatOutput(val,true)]));\n    };\n\n    const formatOutput = function(m,blanks = false) {\n        if(!blanks && m.size === 1) return [...m][0].trim();\n\n        const output = [...m].map(str => str.trim() === '' ? '_' : str);\n        return output.length === 1 ? output[0] : '{' + output.join(', ') + '}';\n    };\n\n    return {\n        run: fitch\n    }\n};\n\nonmessage = function(e) {\n    mss = e.data.readings;\n    levels = e.data.levels;\n    num = e.data.num;\n    id = e.data.id;\n    const result = (new Fitch(mss,levels)).run(id);\n    postMessage({n: num, result: result});\n};\n"],
  "mappings": "AACA,GAAI,GAAI,EAAO,EAAI,EAEb,EAAQ,SAAS,EAAI,EAAQ,CAE/B,GAAM,GAAM,CACR,aAAc,YAAY,EAAM,CAC5B,GAAM,GAAO,EAAK,GAClB,MAAO,IAAI,KACP,CAAC,GAAG,GAAM,OAAO,GAAM,CACnB,OAAQ,GAAE,EAAE,EAAE,EAAK,OAAO,IACtB,GAAG,CAAC,EAAK,GAAG,IAAI,GACZ,MAAO,GAEf,MAAO,OAKnB,MAAO,YAAY,EAAM,CACrB,MAAO,IAAI,KACP,EAAK,OAAO,CAAC,EAAK,IACd,GAAM,CAAC,GAAG,EAAI,GAAG,GACV,GACT,OAKR,EAAS,SAAS,EAAQ,CAC5B,GAAM,GAAY,GAAI,KACtB,OAAU,KAAS,GAAO,GAAI,CAC1B,GAAM,GAAM,EAAI,IAAI,GACd,EAAU,IAAQ,OAAY,CAAC,GAAO,GAC5C,EAAU,IAAI,EAAM,GAAI,KAAI,IAEhC,OAAQ,GAAE,EAAE,EAAE,EAAO,OAAO,IACxB,OAAU,CAAC,EAAK,IAAa,GAAO,GAAI,CACpC,GAAM,GAAW,EAAS,IAAI,GAAQ,EAAU,IAAI,IAC9C,EAAe,EAAI,aAAa,GAAG,GAGzC,GAAG,GAAU,IAAS,GAAU,EAAa,OAAS,EAClD,MAAO,CAAC,GAAG,GAAc,GAE7B,GAAM,GAAS,EAAa,KAAO,EAC/B,EACA,EAAI,MAAM,GAAG,GACjB,EAAU,IAAI,EAAK,GAI3B,MAAO,IAIL,EAAS,SAAS,EAAU,EAAQ,CACtC,GAAM,GAAO,EAAO,GACd,EAAa,GAAI,KAEvB,OAAU,KAAS,GAAO,EAAO,OAAO,GACpC,EAAW,IAAI,EAAM,GAAG,EAAU,IAAI,EAAM,KAEhD,OAAQ,GAAE,EAAO,OAAO,EAAE,EAAE,EAAE,IAC1B,OAAU,CAAC,EAAK,IAAa,GAAO,GAAI,CACpC,GAAM,GAAY,EAAW,IAAI,GACjC,OAAU,KAAS,GAAU,CACzB,GAAG,EAAK,QAAQ,KAAW,GACvB,SACJ,GAAM,GAAe,EAAU,IAAI,GAC7B,EAAU,KAAM,CAClB,GAAG,EAAa,OAAS,EACrB,MAAO,GAEX,GAAM,GAAe,EAAI,aAAa,EAAU,GAChD,MAAO,GAAa,KAAO,EACvB,EACA,MAIR,GAAG,GAAU,IAAU,EACnB,MAAO,GAEX,EAAW,IAAI,EAAM,IAIjC,MAAO,GAAS,EAAW,IAAI,GAAU,GAGvC,EAAQ,SAAS,EAAS,KAAM,CAClC,GAAM,GAAY,EAAO,GACzB,GAAG,MAAO,IAAc,SACpB,MAAO,GAIX,GAAM,GAAa,EAAO,EAAU,GACpC,MAAO,GAAS,EAAa,GACzB,GAAI,KAAI,MAAM,KAAK,EAAW,CAAC,CAAC,EAAI,KAAS,CAAC,EAAI,EAAa,EAAI,QAGrE,EAAe,SAAS,EAAE,EAAS,GAAO,CAC5C,GAAG,CAAC,GAAU,EAAE,OAAS,EAAG,MAAO,CAAC,GAAG,GAAG,GAAG,OAE7C,GAAM,GAAS,CAAC,GAAG,GAAG,IAAI,GAAO,EAAI,SAAW,GAAK,IAAM,GAC3D,MAAO,GAAO,SAAW,EAAI,EAAO,GAAK,IAAM,EAAO,KAAK,MAAQ,KAGvE,MAAO,CACH,IAAK,IAIb,UAAY,SAAS,EAAG,CACpB,EAAM,EAAE,KAAK,SACb,EAAS,EAAE,KAAK,OAChB,EAAM,EAAE,KAAK,IACb,EAAK,EAAE,KAAK,GACZ,GAAM,GAAU,GAAI,GAAM,EAAI,GAAS,IAAI,GAC3C,YAAY,CAAC,EAAG,EAAK,OAAQ",
  "names": []
}
