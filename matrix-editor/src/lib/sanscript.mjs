/**
 * Sanscript
 *
 * Sanscript is a Sanskrit transliteration library. Currently, it supports
 * other Indian languages only incidentally.
 *
 * Released under the MIT and GPL Licenses.
 */

const Sanscript = {};

'use strict';

Sanscript.defaults = {
    skip_sgml: false,
    syncope: false
};

var schemes = Sanscript.schemes = {
        tamil: {
            vowels: ['роЕ','роЖ',
            'роЗ','роИ',
            'роЙ','роК',
            'ЁСМЛ','ЁСНа',
            'ЁСММ','ЁСНб',
            'роО','роП','роР',
            'роТ','роУ','роФ'],
            vowel_marks: ['ро╛',
            'ро┐','рпА',
            'рпБ','рпВ',
            'ЁСНГ','ЁСНД',
            'ЁСНв','ЁСНг',
            'рпЖ','рпЗ','рпИ',
            'рпК','рпЛ','рпМ'],
            other_marks: ['ЁСМВ','ЁСМГ','ЁСМБ','','','роГ'], // с╣Г с╕е m╠Р с║Ц с╕л с╕╡ 
            virama: ['рпН'],
            consonants: ['роХ','ЁСМЦ','ЁСМЧ','ЁСМШ','роЩ',
            'роЪ','ЁСМЫ','роЬ','ЁСМЭ','роЮ',
            'роЯ','ЁСМа','ЁСМб','ЁСМв','рог',
            'род','ЁСМе','ЁСМж','ЁСМз','рои',
            'рок','ЁСМл','ЁСМм','ЁСМн','роо',
            'роп','ро░','ро▓','ро╡',
            'ро╢','ро╖','ро╕','ро╣',
            'ро│','ро┤','ро▒','рой'],
            symbols: ['рпж','рпз','рпи','рпй','рпк','рпл','рпм','рпн','рпо','рпп','рпР','','ЁСМ╜','ред','рее','рп░','рп▒','рп▓'],
        },
        
        grantha: {
            vowels: ['ЁСМЕ','ЁСМЖ',
                'ЁСМЗ','ЁСМИ',
                'ЁСМЙ','ЁСМК',
                'ЁСМЛ','ЁСНа',
                'ЁСММ','ЁСНб',
                'роО','ЁСМП','ЁСМР',
                'роТ','ЁСМУ','ЁСМФ'
              
            ],
            vowel_marks: ['ЁСМ╛',
                'ЁСМ┐','ЁСНА',
                'ЁСНБ','ЁСНВ',
                'ЁСНГ','ЁСНД',
                'ЁСНв','ЁСНг',
                'рпЖ','ЁСНЗ','ЁСНИ',
                'рпК','ЁСНЛ','ЁСНМ'
            ],
            other_marks: ['ЁСМВ','ЁСМГ','ЁСМБ','ЁСНЮ','ЁСНЯ','роГ'], // с╣Г с╕е m╠Р с║Ц с╕л с╕╡ 
            virama: ['ЁСНН'],
            consonants: ['ЁСМХ','ЁСМЦ','ЁСМЧ','ЁСМШ','ЁСМЩ',
                'ЁСМЪ','ЁСМЫ','ЁСМЬ','ЁСМЭ','ЁСМЮ',
                'ЁСМЯ','ЁСМа','ЁСМб','ЁСМв','ЁСМг',
                'ЁСМд','ЁСМе','ЁСМж','ЁСМз','ЁСМи',
                'ЁСМк','ЁСМл','ЁСМм','ЁСМн','ЁСМо',
                'ЁСМп','ЁСМ░','ЁСМ▓','ЁСМ╡',
                'ЁСМ╢','ЁСМ╖','ЁСМ╕','ЁСМ╣',
                'ЁСМ│','ро┤','ро▒','рой',
            ],
            symbols: ['рпж','рпз','рпи','рпй','рпк','рпл','рпм','рпн','рпо','рпп','ЁСНР','','ЁСМ╜','ред','рее','рп░','рп▒','рп▓'],
        },
        
        malayalam: {
            vowels: ['р┤Е','р┤Ж',
                'р┤З','р┤И',
                'р┤Й','р┤К',
                'р┤Л','р╡а',
                'р┤М','р╡б',
                'р┤О','р┤П','р┤Р',
                'р┤Т','р┤У','р┤Ф'
            ],
            vowel_marks: ['р┤╛',
                'р┤┐','р╡А',
                'р╡Б','р╡В',
                'р╡Г','р╡Д',
                'р╡в','р╡г',
                'р╡Ж','р╡З','р╡И',
                'р╡К','р╡Л','р╡М'
            ],
            other_marks: ['р┤В','р┤Г','р┤Б','','',''],
            virama: ['р╡Н'],
            consonants: ['р┤Х','р┤Ц','р┤Ч','р┤Ш','р┤Щ',
                'р┤Ъ','р┤Ы','р┤Ь','р┤Э','р┤Ю',
                'р┤Я','р┤а','р┤б','р┤в','р┤г',
                'р┤д','р┤е','р┤ж','р┤з','р┤и',
                'р┤к','р┤л','р┤м','р┤н','р┤о',
                'р┤п','р┤░','р┤▓','р┤╡',
                'р┤╢','р┤╖','р┤╕','р┤╣',
                'р┤│','р┤┤','р┤▒','р┤й'
            ],
            symbols: ['р╡ж','р╡з','р╡и','р╡й','р╡к','р╡л','р╡м','р╡н','р╡о','р╡п','р┤Тр┤В','','р┤╜','ред','рее','р╡░','р╡▒','р╡▓'],
        },
        
        newa: {
            vowels: ['ЁСРА','ЁСРБ',
                'ЁСРВ','ЁСРГ',
                'ЁСРД','ЁСРЕ',
                'ЁСРЖ','ЁСРЗ',
                'ЁСРИ','ЁСРЙ',
                '','ЁСРК','ЁСРЛ',
                '','ЁСРМ','ЁСРН'
            ],
            vowel_marks: ['ЁСР╡',
                'ЁСР╢','ЁСР╖',
                'ЁСР╕','ЁСР╣',
                'ЁСР║','ЁСР╗',
                'ЁСР╝','ЁСР╜',
                '','ЁСР╛','ЁСР┐',
                '','ЁССА','ЁССБ',
            ],
            other_marks: ['ЁССД','ЁССЕ','ЁССГ','ЁССа','ЁССб',''],
            virama: ['ЁССВ'],
            consonants: ['ЁСРО','ЁСРП','ЁСРР','ЁСРС','ЁСРТ',
                'ЁСРФ','ЁСРХ','ЁСРЦ','ЁСРЧ','ЁСРШ',
                'ЁСРЪ','ЁСРЫ','ЁСРЬ','ЁСРЭ','ЁСРЮ',
                'ЁСРЯ','ЁСРа','ЁСРб','ЁСРв','ЁСРг',
                'ЁСРе','ЁСРж','ЁСРз','ЁСРи','ЁСРй',
                'ЁСРл','ЁСРм','ЁСРо','ЁСР░',
                'ЁСР▒','ЁСР▓','ЁСР│','ЁСР┤'
            ],
            symbols: ['ЁССР','ЁССС','ЁССТ','ЁССУ','ЁССФ','ЁССХ','ЁССЦ','ЁССЧ','ЁССШ','ЁССЩ',
            'ЁССЙ','','ЁССЗ','ЁССЛ','ЁССМ']
        },
        
        sarada: {
            vowels: ['ЁСЖГ','ЁСЖД',
                'ЁСЖЕ','ЁСЖЖ',
                'ЁСЖЗ','ЁСЖИ',
                'ЁСЖЙ','ЁСЖК',
                'ЁСЖЛ','ЁСЖМ',
                '','ЁСЖН','ЁСЖО',
                '','ЁСЖП','ЁСЖР'
            ],
            vowel_marks: ['ЁСЖ│',
                'ЁСЖ┤','ЁСЖ╡',
                'ЁСЖ╢','ЁСЖ╖',
                'ЁСЖ╕','ЁСЖ╣',
                'ЁСЖ║','ЁСЖ╗',
                '','ЁСЖ╝','ЁСЖ╜',
                '','ЁСЖ╛','ЁСЖ┐'
            ],
            other_marks: ['ЁСЖБ','ЁСЖВ','ЁСЖА','ЁСЗБ','ЁСЗВ',''],
            virama: ['ЁСЗА'],
            consonants: ['ЁСЖС','ЁСЖТ','ЁСЖУ','ЁСЖФ','ЁСЖХ',
                'ЁСЖЦ','ЁСЖЧ','ЁСЖШ','ЁСЖЩ','ЁСЖЪ',
                'ЁСЖЫ','ЁСЖЬ','ЁСЖЭ','ЁСЖЮ','ЁСЖЯ',
                'ЁСЖа','ЁСЖб','ЁСЖв','ЁСЖг','ЁСЖд',
                'ЁСЖе','ЁСЖж','ЁСЖз','ЁСЖи','ЁСЖй',
                'ЁСЖк','ЁСЖл','ЁСЖм','ЁСЖо',
                'ЁСЖп','ЁСЖ░','ЁСЖ▒','ЁСЖ▓',
                'ЁСЖн'
            ],
            symbols: ['ЁСЗР','ЁСЗС','ЁСЗТ','ЁСЗУ','ЁСЗФ','ЁСЗХ','ЁСЗЦ','ЁСЗЧ','ЁСЗШ','ЁСЗЩ',
                'ЁСЗД','','ЁСЗБ','ЁСЗЕ','ЁСЗЖ']
        },

        nandinagari: {
            vowels: ['\u{119A0}','\u{119A1}',
                '\u{119A2}','\u{119A3}',
                '\u{1194}','\u{119A5}',
                '\u{119A6}','\u{119A7}',
                '\u{119C9}\u{119D6}','\u{119C9}\u{119D7}',
                '','\u{119AA}','\u{119AB}',
                '','\u{119AC}','\u{119AD}'
            ],
            vowel_marks: ['\u{119D1}',
                '\u{119D2}','\u{119D3}',
                '\u{119D4}','\u{119D5}',
                '\u{119D6}','\u{119D7}',
                '\u{119C9}\u{119D6}','\u{119C9}\u{119D7}',
                '','\u{119DA}','\u{119DB}',
                '','\u{119DC}','\u{119DD}'
            ],
            other_marks: ['\u{119DE}','\u{119DF}','','',''],
            virama: ['\u{119E0}'],
            consonants: ['\u{119AE}','\u{119AF}','\u{119B0}','\u{119B1}','\u{11B2}',
                '\u{119B3}','\u{119B4}','\u{119B5}','\u{119B6}','\u{119B7}',
                '\u{119B8}','\u{119B9}','\u{119BA}','\u{119BB}','\u{119BC}',
                '\u{119BD}','\u{119BE}','\u{119BF}','\u{119C0}','\u{119C1}',
                '\u{119C2}','\u{119C3}','\u{119C4}','\u{119C5}','\u{119C6}',
                '\u{119C7}','\u{119C8}','\u{119C9}','\u{119CA}',
                '\u{119CB}','\u{119CC}','\u{119CD}','\u{119CE}',
                '\u{119CF}','','\u{119D0}'
            ],
            // use Kannada numerals & Devanagari daс╣Зс╕Нas
            symbols: ['р│ж','р│з','р│и','р│й','р│к','р│л','р│м','р│н','р│о','р│п',
                '\u{119AC}\u{119DE}','','\u{119E1}','ред','рее']
        },

        bengali: {
            vowels: ['ржЕ','ржЖ',
            'ржЗ','ржИ',
            'ржЙ','ржК',
            'ржЛ','рза',
            'ржМ','рзб',
            '','ржП','ржР',
            '','ржУ','ржФ'],
            vowel_marks: ['рж╛',
            'рж┐','рзА',
            'рзБ','рзВ',
            'рзГ','рзД',
            'рзв','рзг',
            '','рзЗ','рзИ',
            'рзЛ','рзМ'],
            other_marks: ['ржВ','ржГ','ржБ','','',''],
            virama: ['рзН'],
            consonants: ['ржХ','ржЦ','ржЧ','ржШ','ржЩ',
            'ржЪ','ржЫ','ржЬ','ржЭ','ржЮ',
            'ржЯ','ржа','ржб','ржв','ржг',
            'ржд','рже','ржж','ржз','ржи',
            'ржк','ржл','ржм','ржн','ржо',
            'ржп','рж░','рж▓','ржм',
            'рж╢','рж╖','рж╕','рж╣',
            'рд│','','','',
            'ржпрж╝',
            '','','','','','','рзЬ','рзЭ' // (q qh ─б z zh f) с╣Щ с╣Щh (с╣лh с╕Лh w)
            ],
            symbols: ['рзж','рзз','рзи','рзй','рзк','рзл','рзм','рзн','рзо','рзп','ржУржБ','','рж╜','ред','рее'],
        },
        devanagari: {
            vowels: ['рдЕ','рдЖ', // a ─Б
            'рдЗ','рдИ', // i ─л
            'рдЙ','рдК', // u ┼л
            'рдЛ','реа', // с╣Ы с╣Э
            'рдМ','реб', // l╠е l╠Д╠е
            'рдО','рдП','рдР', // e ─У ai
            'рдТ','рдУ','рдФ' // o ┼Н au
            ],
            vowel_marks: ['рд╛', // ─Б
            'рд┐','реА', // i ─л
            'реБ','реВ', // u ┼л
            'реГ','реД', // с╣Ы с╣Э
            'рев','рег', // l╠е l╠Д╠е
            'реЖ','реЗ','реИ', // e ─У ai
            'реК','реЛ','реМ', // o ┼Н au
            'реО','реОреЗ','реОрд╛','реОреЛ' // e ai o au
            ],
            
            other_marks: ['рдВ','рдГ','рдБ','с│╡','с│╢',''], // с╣Г с╕е m╠Р с║Ц с╕л с╕╡ 

            virama: ['реН'],

            consonants: ['рдХ','рдЦ','рдЧ','рдШ','рдЩ',
            'рдЪ','рдЫ','рдЬ','рдЭ','рдЮ',
            'рдЯ','рда','рдб','рдв','рдг',
            'рдд','рде','рдж','рдз','рди',
            'рдк','рдл','рдм','рдн','рдо',     
            'рдп','рд░','рд▓','рд╡',
            'рд╢','рд╖','рд╕','рд╣',
            'рд│','рд┤','рд▒','рдирд╝',
            'рдпрд╝',
            'рдХрд╝','рдЦрд╝','рдЧрд╝','рдЬрд╝','рдЭрд╝','рдлрд╝','рдбрд╝','рдврд╝','рдерд╝','рдзрд╝','рд╡рд╝' // q qh ─б z zh f с╣Щ с╣Щh с╣лh с╕Лh w
            ],

            symbols: ['реж','рез','реи','рей','рек','рел','рем','рен','рео','реп','реР','ъг╜','рд╜','ред','рее'],

            zwj: ['\u200D'],

            // Dummy consonant. This is used in ITRANS to prevert certain types
            // of parser ambiguity. Thus "barau" -> рдмрд░реМ but "bara_u" -> рдмрд░рдЙ.
            skip: [''],

            // Vedic accent. Udatta and anudatta.
            accent: ['\u0951', '\u0952'],

            // Accent combined with anusvara and and visarga. For compatibility
            // with ITRANS, which allows the reverse of these four.
            combo_accent: 'рдГреС рдГреТ рдВреС рдВреТ'.split(' '),
        },
        telugu: {
            vowels: ['р░Е','р░Ж', // a ─Б
            'р░З','р░И', // i ─л
            'р░Й','р░К', // u ┼л
            'р░Л','р▒а', // с╣Ы с╣Э
            'р░М','р▒б', // l╠е l╠Д╠е
            'р░О','р░П','р░Р', // e ─У ai
            'р░Т','р░У','р░Ф' // o ┼Н au
            ],
            vowel_marks: ['р░╛', // ─Б
            'р░┐','р▒А', // i ─л
            'р▒Б','р▒В', // u ┼л
            'р▒Г','р▒Д', // с╣Ы r╠Д,
            'р▒в','р▒г', // l╠е l╠Д╠е
            'р▒Ж','р▒З','р▒И', // e ─У ai
            'р▒К','р▒Л','р▒М' // o ┼Н au
            ],
            other_marks: ['р░В','р░Г','р░А','','',''], // с╣Г с╕е m╠Р с║Ц с╕л с╕╡ (what about ardh─Бnusv─Бra?)
            virama: ['р▒Н'],
            consonants: ['р░Х','р░Ц','р░Ч','р░Ш','р░Щ', // k kh g gh с╣Е
            'р░Ъ','р░Ы','р░Ь','р░Э','р░Ю', // c ch j jh ├▒
            'р░Я','р░а','р░б','р░в','р░г', // с╣н с╣нh с╕Н с╕Нh с╣З
            'р░д','р░е','р░ж','р░з','р░и', // t th d dh n
            'р░к','р░л','р░м','р░н','р░о', // p ph b bh m
            'р░п','р░░','р░▓','р░╡', // y r l v
            'р░╢','р░╖','р░╕','р░╣', // ┼Ы с╣г s h
            'р░│','р░┤','р░▒'], // с╕╖ с╕╗ с╣Я
            symbols: ['р▒ж','р▒з','р▒и','р▒й','р▒к','р▒л','р▒м','р▒н','р▒о','р▒п','р░Ур░В','','р░╜','ред','рее'],
        },

        iast: {
            vowels: ['a','─Б',
            'i','─л',
            'u','┼л',
            'с╣Ы','с╣Э',
            'l╠е','l╠е╠Д',
            'e','─У','ai',
            'o','┼Н','au',
            '├к','a├о','├┤','a├╗'], // Devan─Бgar─л pс╣Ыс╣гtham─Бtr─Бs
            other_marks: ['с╣Г','с╕е','m╠Р','с║Ц','с╕л','с╕╡'],
            virama: [''],
            consonants: ['k','kh','g','gh','с╣Е',
            'c','ch','j','jh','├▒',
            'с╣н','с╣нh','с╕Н','с╕Нh','с╣З',
            't','th','d','dh','n',
            'p','ph','b','bh','m',
            'y','r','l','v',
            '┼Ы','с╣г','s','h',
            'с╕╖','с╕╗','с╣Я','с╣Й', // Dravidian
            'с║П', // Bengali
            'q','qh','─б','z','zh','f','с╣Щ','с╣Щh','с╣лh','с╕Лh','w'],
            symbols: ['0','1','2','3','4','5','6','7','8','9','oс╣Б','oс╕┐','\'','|','||','тБ░','тБ░тБ░','тБ░тБ░тБ░'],
        }
    },

    // Set of names of schemes
    romanSchemes = {},

    // Map of alternate encodings.
    allAlternates = {
    },

    // object cache
    cache = {};

/**
 * Check whether the given scheme encodes romanized Sanskrit.
 *
 * @param name  the scheme name
 * @return      boolean
 */
Sanscript.isRomanScheme = function(name) {
    return romanSchemes.hasOwnProperty(name);
};

/**
 * Add a Brahmic scheme to Sanscript.
 *
 * Schemes are of two types: "Brahmic" and "roman". Brahmic consonants
 * have an inherent vowel sound, but roman consonants do not. This is the
 * main difference between these two types of scheme.
 *
 * A scheme definition is an object ("{}") that maps a group name to a
 * list of characters. For illustration, see the "devanagari" scheme at
 * the top of this file.
 *
 * You can use whatever group names you like, but for the best results,
 * you should use the same group names that Sanscript does.
 *
 * @param name    the scheme name
 * @param scheme  the scheme data itself. This should be constructed as
 *                described above.
 */
Sanscript.addBrahmicScheme = function(name, scheme) {
    Sanscript.schemes[name] = scheme;
};

/**
 * Add a roman scheme to Sanscript.
 *
 * See the comments on Sanscript.addBrahmicScheme. The "vowel_marks" field
 * can be omitted.
 *
 * @param name    the scheme name
 * @param scheme  the scheme data itself
 */
Sanscript.addRomanScheme = function(name, scheme) {
    if (!('vowel_marks' in scheme)) {
        scheme.vowel_marks = scheme.vowels.slice(1);
    }
    Sanscript.schemes[name] = scheme;
    romanSchemes[name] = true;
};

/**
 * Create a deep copy of an object, for certain kinds of objects.
 *
 * @param scheme  the scheme to copy
 * @return        the copy
 */
/*
var cheapCopy = function(scheme) {
    var copy = {};
    for (var key in scheme) {
        if (!scheme.hasOwnProperty(key)) {
            continue;
        }
        copy[key] = scheme[key].slice(0);
    }
    return copy;
};
*/
// Set up various schemes
(function() {
    // Set up roman schemes
    /*
    var kolkata = schemes.kolkata = cheapCopy(schemes.iast),
        schemeNames = 'iast itrans hk kolkata slp1 velthuis wx'.split(' ');
    kolkata.vowels = 'a ─Б i ─л u ┼л с╣Ы с╣Э с╕╖ с╕╣ e ─У ai o ┼Н au'.split(' ');
    */
    var schemeNames = ['iast'];
    // These schemes already belong to Sanscript.schemes. But by adding
    // them again with `addRomanScheme`, we automatically build up
    // `romanSchemes` and define a `vowel_marks` field for each one.
    for (var i = 0, name; (name = schemeNames[i]); i++) {
        Sanscript.addRomanScheme(name, schemes[name]);
    }
    /*
    // ITRANS variant, which supports Dravidian short 'e' and 'o'.
    var itrans_dravidian = cheapCopy(schemes.itrans);
    itrans_dravidian.vowels = 'a A i I u U Ri RRI LLi LLi e E ai o O au'.split(' ');
    itrans_dravidian.vowel_marks = itrans_dravidian.vowels.slice(1);
    allAlternates.itrans_dravidian = allAlternates.itrans;
    Sanscript.addRomanScheme('itrans_dravidian', itrans_dravidian);
*/
}());

/**
 * Create a map from every character in `from` to its partner in `to`.
 * Also, store any "marks" that `from` might have.
 *
 * @param from     input scheme
 * @param to       output scheme
 * @param options  scheme options
 */
var makeMap = function(from, to, /*options*/) {
    var alternates = allAlternates[from] || {},
        consonants = {},
        fromScheme = Sanscript.schemes[from],
        letters = {},
        tokenLengths = [],
        marks = {},
        toScheme = Sanscript.schemes[to];

    for (var group in fromScheme) {
        if (!fromScheme.hasOwnProperty(group)) {
            continue;
        }
        var fromGroup = fromScheme[group],
            toGroup = toScheme[group];
        if (toGroup === undefined) {
            continue;
        }
        for (var i = 0; i < fromGroup.length; i++) {
            var F = fromGroup[i],
                T = toGroup[i],
                alts = alternates[F] || [],
                numAlts = alts.length,
                j = 0;

            tokenLengths.push(F.length);
            for (j = 0; j < numAlts; j++) {
                tokenLengths.push(alts[j].length);
            }

            if (group === 'vowel_marks' || group === 'virama') {
                marks[F] = T;
                for (j = 0; j < numAlts; j++) {
                    marks[alts[j]] = T;
                }
            } else {
                letters[F] = T;
                for (j = 0; j < numAlts; j++) {
                    letters[alts[j]] = T;
                }
                if (group === 'consonants' || group === 'other') {
                    consonants[F] = T;

                    for (j = 0; j < numAlts; j++) {
                        consonants[alts[j]] = T;
                    }
                }
            }
        }
    }
    return {consonants: consonants,
        fromRoman: Sanscript.isRomanScheme(from),
        letters: letters,
        marks: marks,
        maxTokenLength: Math.max.apply(Math, tokenLengths),
        toRoman: Sanscript.isRomanScheme(to),
        virama: toScheme.virama};
};

/**
 * Transliterate from a romanized script.
 *
 * @param data     the string to transliterate
 * @param map      map data generated from makeMap()
 * @param options  transliteration options
 * @return         the finished string
 */
var transliterateRoman = function(data, map, options) {
    var buf = [],
        consonants = map.consonants,
        dataLength = data.length,
        hadConsonant = false,
        letters = map.letters,
        marks = map.marks,
        maxTokenLength = map.maxTokenLength,
        optSkipSGML = options.skip_sgml,
        optSyncope = options.syncope,
        tempLetter,
        tempMark,
        tokenBuffer = '',
        toRoman = map.toRoman,
        virama = map.virama;

    // Transliteration state. It's controlled by these values:
    // - `skippingSGML`: are we in SGML?
    // - `toggledTrans`: are we in a toggled region?
    //
    // We combine these values into a single variable `skippingTrans`:
    //
    //     `skippingTrans` = skippingSGML || toggledTrans;
    //
    // If (and only if) this value is true, don't transliterate.
    var skippingSGML = false,
        skippingTrans = false,
        toggledTrans = false;

    for (var i = 0, L; (L = data.charAt(i)) || tokenBuffer; i++) {
        // Fill the token buffer, if possible.
        var difference = maxTokenLength - tokenBuffer.length;
        if (difference > 0 && i < dataLength) {
            tokenBuffer += L;
            if (difference > 1) {
                continue;
            }
        }

        // Match all token substrings to our map.
        for (var j = 0; j < maxTokenLength; j++) {
            var token = tokenBuffer.substr(0,maxTokenLength-j);

            if (skippingSGML === true) {
                skippingSGML = (token !== '>');
            } else if (token === '<') {
                skippingSGML = optSkipSGML;
            } else if (token === '##') {
                toggledTrans = !toggledTrans;
                tokenBuffer = tokenBuffer.substr(2);
                break;
            }
            skippingTrans = skippingSGML || toggledTrans;
            if ((tempLetter = letters[token]) !== undefined && !skippingTrans) {
                if (toRoman) {
                    buf.push(tempLetter);
                } else {
                    // Handle the implicit vowel. Ignore 'a' and force
                    // vowels to appear as marks if we've just seen a
                    // consonant.
                    if (hadConsonant) {
                        if ((tempMark = marks[token])) {
                            buf.push(tempMark);
                        } else if (token !== 'a') {
                            buf.push(virama);
                            buf.push(tempLetter);
                        }
                    } else {
                        buf.push(tempLetter);
                    }
                    hadConsonant = token in consonants;
                }
                tokenBuffer = tokenBuffer.substr(maxTokenLength-j);
                break;
            } else if (j === maxTokenLength - 1) {
                if (hadConsonant) {
                    hadConsonant = false;
                    if (!optSyncope) {
                        buf.push(virama);
                    }
                }
                buf.push(token);
                tokenBuffer = tokenBuffer.substr(1);
                // 'break' is redundant here, "j == ..." is true only on
                // the last iteration.
            }
        }
    }
    if (hadConsonant && !optSyncope) {
        buf.push(virama);
    }
    return buf.join('');
};

/**
 * Transliterate from a Brahmic script.
 *
 * @param data     the string to transliterate
 * @param map      map data generated from makeMap()
 * @param options  transliteration options
 * @return         the finished string
 */
var transliterateBrahmic = function(data, map, /*options*/) {
    var buf = [],
        consonants = map.consonants,
        hadRomanConsonant = false,
        letters = map.letters,
        marks = map.marks,
        dataLength = data.length,
        maxTokenLength = map.maxTokenLength,
        tempLetter,
        tokenBuffer = '',
        toRoman = map.toRoman,
        skippingTrans = false;

    for (var i = 0, L; (L = data.charAt(i)) || tokenBuffer; i++) {
        // Fill the token buffer, if possible.
        var difference = maxTokenLength - tokenBuffer.length;
        if (difference > 0 && i < dataLength) {
            tokenBuffer += L;
            if (difference > 1) {
                continue;
            }
        }

        // Match all token substrings to our map.
        for (var j = 0; j < maxTokenLength; j++) {
            var token = tokenBuffer.substr(0,maxTokenLength-j);

            if((tempLetter = marks[token]) !== undefined && !skippingTrans) {
                buf.push(tempLetter);
                hadRomanConsonant = false;
                tokenBuffer = tokenBuffer.substr(maxTokenLength-j);
                break;
            } 
            else if((tempLetter = letters[token])) {
                if (hadRomanConsonant) {
                    buf.push('a');
                    hadRomanConsonant = false;
                }
                buf.push(tempLetter);
                hadRomanConsonant = toRoman && (token in consonants);
                tokenBuffer = tokenBuffer.substr(maxTokenLength-j);
                break;

            } else if (j === maxTokenLength - 1) {
                if (hadRomanConsonant) {
                    buf.push('a');
                    hadRomanConsonant = false;
                }
                buf.push(token);
                tokenBuffer = tokenBuffer.substr(1);
            }
        }
    }
    if (hadRomanConsonant) {
        buf.push('a');
    }
    return buf.join('');
};

/**
 * Transliterate from one script to another.
 *
 * @param data     the string to transliterate
 * @param from     the source script
 * @param to       the destination script
 * @param options  transliteration options
 * @return         the finished string
 */
Sanscript.t = function(data, from, to, options) {
    options = options || {};
    var cachedOptions = cache.options || {},
        defaults = Sanscript.defaults,
        hasPriorState = (cache.from === from && cache.to === to),
        map;

    // Here we simultaneously build up an `options` object and compare
    // these options to the options from the last run.
    for (var key in defaults) {
        if (defaults.hasOwnProperty(key)) {
            var value = defaults[key];
            if (key in options) {
                value = options[key];
            }
            options[key] = value;

            // This comparison method is not generalizable, but since these
            // objects are associative arrays with identical keys and with
            // values of known type, it works fine here.
            if (value !== cachedOptions[key]) {
                hasPriorState = false;
            }
        }
    }

    if (hasPriorState) {
        map = cache.map;
    } else {
        map = makeMap(from, to, options);
        cache = {
            from: from,
            map: map,
            options: options,
            to: to};
    }
    /*
    // Easy way out for "{\m+}", "\", and ".h".
    if (from === 'itrans') {
        data = data.replace(/\{\\m\+\}/g, '.h.N');
        data = data.replace(/\.h/g, '');
        data = data.replace(/\\([^'`_]|$)/g, '##$1##');
    }
    */
    if (map.fromRoman) {
        return transliterateRoman(data, map, options);
    } else {
        return transliterateBrahmic(data, map, options);
    }
};

export { Sanscript };
